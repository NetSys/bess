#!/usr/bin/env python2.7
import sys
import os
import os.path
import pprint
import cStringIO
import tempfile

import cli
import commands

try:
    this_dir = os.path.dirname(os.path.realpath(__file__))
    sys.path.insert(1, '%s/../libbess-python' % this_dir)
    from bess import *
except ImportError:
    print >> sys.stderr, 'Cannot import the API module (libbess-python)'
    raise

class BESSCLI(cli.CLI):
    def __init__(self, bess, cmd_db, fin=sys.stdin,
                 fout=sys.stdout, history_file=None):
        self.bess = bess
        self.cmd_db = cmd_db
        self.this_dir = this_dir

        super(BESSCLI, self).__init__(self.cmd_db.cmdlist, fin=fin, fout=fout,
                                      history_file=history_file)

    def get_var_attrs(self, var_token, partial_word):
        return self.cmd_db.get_var_attrs(self, var_token, partial_word)

    def split_var(self, var_type, line):
        try:
            return self.cmd_db.split_var(self, var_type, line)
        except self.InternalError:
            return super(BESSCLI, self).split_var(var_type, line)

    def bind_var(self, var_type, line):
        try:
            return self.cmd_db.bind_var(self, var_type, line)
        except self.InternalError:
            return super(BESSCLI, self).bind_var(var_type, line)

    def print_banner(self):
        self.fout.write('Type "help" for more information.\n')

    def get_default_args(self):
        return [self]

    def call_func(self, func, args):
        try:
            super(BESSCLI, self).call_func(func, args)
        except self.bess.APIError as e:
            self.err(e)
            raise self.HandledError()
        except self.bess.Error as e:
            self.err(e.errmsg)

            if e.err in errno.errorcode:
                err_code = errno.errorcode[e.err]
            else:
                err_code = '<unknown>'

            self.ferr.write('  BESS daemon response - errno=%d (%s: %s)\n' %
                            (e.err, err_code, os.strerror(e.err)))

            if e.details:
                details = pprint.pformat(e.details)
                initial_indent = '  error details: '
                subsequent_indent = ' ' * len(initial_indent)

                for i, line in enumerate(details.splitlines()):
                    if i == 0:
                        self.fout.write('%s%s\n' % (initial_indent, line))
                    else:
                        self.fout.write('%s%s\n' % (subsequent_indent, line))

            raise self.HandledError()

    def print_crashlog(self):
        try:
            log_path = tempfile.gettempdir() + '/bessd_crash.log'
            log = open(log_path).read()
            self.fout.write(log)
        except:
            pass

    def loop(self):
        super(BESSCLI, self).loop()
        # TODO: raise an exception when gRPC abnormaly disconnects
        # Then use self.print_crashlog() to print out the call stack trace
        # when the bessd daemon process aborts
        self.bess.disconnect()

    def get_prompt(self):
        if self.bess.is_connected():
            return '%s:%d $ ' % self.bess.peer
        else:
            return '<disconnected> $ '


def run_cli():
    try:
        hist_file = os.path.expanduser('~/.bess_history')
        open(hist_file, 'a+').close()
    except:
        print >> sys.stderr, 'Error: Cannot open ~/.bess_history'
        hist_file = None
        raise

    try:
        s = BESS()
        s.connect()
    except BESS.APIError as e:
        print >> sys.stderr, e.message, '(bessd daemon is not running?)'

    cli = BESSCLI(s, commands, history_file=hist_file)
    cli.loop()


def run_cmds(instream):
    try:
        s = BESS()
        s.connect()
    except BESS.APIError as e:
        # show no error msg, since user might be about to launch the daemon
        pass

    cli = BESSCLI(s, commands, fin=instream, history_file=None)
    cli.loop()

    # end of loop due to error?
    if cli.stop_loop:
        if cli.last_cmd:
            cli.ferr.write('  Command failed: %s\n' % cli.last_cmd)
        sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) == 1:
        run_cli()
    else:
        cmds = []
        line_buf = []

        for arg in sys.argv[1:]:
            if arg == '--':
                cmds.append(' '.join(line_buf))
                line_buf = []
            else:
                line_buf.append(arg)

        cmds.append(' '.join(line_buf))
        run_cmds(cStringIO.StringIO('\n'.join(cmds)))
