import scapy.all as scapy

pkt_size = int($SN_PKT_SIZE!'60')
num_ports = int($SN_PORTS!'1')
num_cores = int($SN_CORES!'1')
rate_limit = int($BESS_RATELIMIT_MBPS!'0') # default no limit
imix = int($SN_IMIX!'0')

assert(60 <= pkt_size <= 1522)
assert(1 <= num_ports <= 16)
assert(1 <= num_cores <= 4)

# generate flows by varying dst IP addr
num_flows = int($SN_FLOWS!'1')
assert(1 <= num_flows <= 256 ** 3)

def build_pkt(size):
    eth = scapy.Ether(src='02:1e:67:9f:4d:ae', dst='06:16:3e:1b:72:32')
    ip = scapy.IP(src='192.168.0.1', dst='10.0.0.1')
    udp = scapy.UDP(sport=10001, dport=10002)
    payload = ('hello' + '0123456789' * 200)[:size-len(eth/ip/udp)]
    pkt = eth/ip/udp/payload
    pkt.show()
    return str(pkt)

if imix:
    # https://en.wikipedia.org/wiki/Internet_Mix
    pkt_templates = [
            build_pkt(60),
            build_pkt(60),
            build_pkt(60),
            build_pkt(60),
            build_pkt(60),
            build_pkt(60),
            build_pkt(60),
            build_pkt(590),
            build_pkt(590),
            build_pkt(590),
            build_pkt(1514)
            ]
else:
    pkt_templates = [build_pkt(pkt_size)]

ports = [PMDPort(port_id=i, num_inc_q=num_cores, num_out_q=num_cores) \
         for i in range(num_ports)]

if(rate_limit != 0):
    bess.add_tc('rr', policy='round_robin', priority=0)

for i in range(num_cores):
    if(rate_limit == 0):
        print("starting up worker: " + str(i))
        bess.add_worker(wid=i, core=i)

    src = Source()
    rr = RoundRobin(gates=range(num_ports))
    src \
    -> Rewrite(templates=pkt_templates) \
    -> RandomUpdate(fields=[{'offset': 30, 'size': 4, 'min': 0x0a000001, 'max': 0x0a000001 + num_flows - 1}]) \
    -> IPChecksum() \
    -> rr

    if(rate_limit != 0):
        bess.add_tc('bit_limit', parent='rr', policy='rate_limit', resource='bit', limit={'bit': rate_limit * 1000000})
        bess.add_tc('bit_leaf', policy='leaf', parent='bit_limit')
        bess.attach_task(src.name, tc='bit_leaf')

    for j in range(num_ports):
        rr:j -> Update(fields=[{'offset': 29, 'size': 1, 'value': j+1}]) -> QueueOut(port=ports[j].name, qid=i)
        QueueInc(port=ports[j].name, qid=i) -> Sink()

