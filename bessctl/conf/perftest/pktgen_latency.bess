import scapy.all as scapy
import time

pkt_size = int($SN_PKT_SIZE!'100')
num_ports = int($SN_PORTS!'1')
num_cores = int($SN_CORES!num_ports)
burst = int($SN_BURST!'32')
mbps = int($SN_MBPS!'100')

assert(63 <= pkt_size <= 1522)
assert(1 <= num_ports <= 16)
assert(1 <= num_cores <= 4)

# generate flows by varying dst IP addr
num_flows = int($SN_FLOWS!'1024')
assert(1 <= num_flows <= 256 ** 3)

eth = scapy.Ether(src='02:1e:67:9f:4d:ae', dst='06:16:3e:1b:72:32')
ip = scapy.IP(src='192.168.0.1', dst='10.0.0.1')
udp = scapy.UDP(sport=10001, dport=10002)
payload = ('hello' + '0123456789' * 200)[:pkt_size-len(eth/ip/udp)]

pkt = eth/ip/udp/payload
print 'Packet template:'
pkt.show()
pkt_bytes = str(pkt)
assert(len(pkt_bytes) == pkt_size)

bess.add_tc('rr', policy='round_robin', priority=0)
ms = [] 

for i in range(num_ports):
    suffix_out = '_out_%d' % (i,)
    rl_out = 'rl' + suffix_out
    leaf_out = 'leaf' + suffix_out
    bps = long(mbps / float(num_ports) * 1e6)
    bess.add_tc(rl_out, policy='rate_limit', parent='rr',
                resource='bit', limit={'bit': bps})
    bess.add_tc(leaf_out, parent=rl_out, policy='leaf')

    p = PMDPort(port_id=i)
    s = Source(burst=burst)
    s -> Rewrite(templates=[pkt_bytes,]) \
    -> RandomUpdate(fields=[{'offset': 30,
        'size': 4,
        'min': 0x0a000001,
        'max': 0x0a000001 + num_flows - 1}]) \
    -> IPChecksum() \
    -> Queue() \
    -> Timestamp() \
    -> PortOut(port=p.name)
    bess.attach_task(s.name, tc=leaf_out)

    m = Measure()
    PortInc(port=p.name) -> m -> Sink()
    ms.append(m)

m = ms[0]
last = dict([(m, m.get_summary()) for m in ms])

while True:
    bess.resume_all()
    time.sleep(1)
    bess.pause_all()

    print '====='
    avg_50 = 0
    avg_99 = 0
    min_50 = 0
    min_99 = 0
    max_50 = 0
    max_99 = 0

    for i in range(len(ms)):
        m = ms[i]
        now = m.get_summary()
        diff_ts = last[m].timestamp - now.timestamp
        diff_pkts = (last[m].packets - now.packets) / diff_ts
        diff_bits = (last[m].bits - now.bits) / diff_ts
        diff_total_latency_ns = (last[m].total_latency_ns - now.total_latency_ns) / diff_ts
        diff_latency_50_ns = (last[m].latency_50_ns - now.latency_50_ns) / diff_ts
        diff_latency_99_ns = (last[m].latency_99_ns - now.latency_99_ns) / diff_ts
        last[m] = now

        if diff_pkts >= 1.0:
            ns_per_packet = diff_total_latency_ns / diff_pkts
        else:
            ns_per_packet = 0

        l_50 = last[m].latency_50_ns
        l_99 = last[m].latency_99_ns
        print '[port %d] %s: %.3f Mpps, %.3f Mbps, %.3f us, %.3f us, %.3f us' % \
                (i,
                 time.ctime(now.timestamp),
                 diff_pkts / 1e6,
                 diff_bits / 1e6,
                 ns_per_packet / 1e3,
                 l_50 / 1e3,
                 l_99 / 1e3)
        avg_50 += l_50
        avg_99 += l_99
        l_50 = l_50 / 1e3
        l_99 = l_99 / 1e3
        if l_50 > max_50: max_50 = l_50
        if l_99 > max_99: max_99 = l_99
        if l_50 < min_50 or min_50 == 0: min_50 = l_50
        if l_99 < min_99 or min_99 == 0: min_99 = l_99

    print 'min: %.3f us, %.3f us' % (min_50, min_99)
    print 'avg: %.3f us, %.3f us' % (avg_50 / len(ms) / 1e3,
                                     avg_99 / len(ms) / 1e3)
    print 'max: %.3f us, %.3f us' % (max_50, max_99)
