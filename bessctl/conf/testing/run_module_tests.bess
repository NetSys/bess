# Copyright (c) 2016-2017, Nefeli Networks, Inc.
# Copyright (c) 2017, Cloudigo.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# * Neither the names of the copyright holders nor the names of their
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import scapy.all as scapy
import sys
import os
import glob
import socket
import time
import sugar
import traceback
from time import gmtime, strftime

# Env variable used to run a single test
test_name = $TEST_NAME!'*'

## HANDY UTILS AND GLOBAL VARS ##
SOCKET_PATH = '/tmp/bess_unix_'
SCRIPT_STARTTIME = strftime("%Y-%m-%d-%H-%M-%S", gmtime())

# Generate a UnixSocketPort and a Socket to talk to it
def gen_socket_and_port(sockname, timeout_sec=5):
    socket_port = UnixSocketPort(
        name=sockname,
        path='@' +
        SOCKET_PATH +
        sockname)

    s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    s.settimeout(timeout_sec)
    s.connect('\0' + SOCKET_PATH + sockname)
    return socket_port, s

# Craft a packet with the specified IP addresses
# All the other fields -- Ether, ports -- are dummy values.
def gen_packet(proto, src_ip, dst_ip, ip_ttl=64, srcport=1001, dstport=1002):
    eth = scapy.Ether(src='02:1e:67:9f:4d:ae', dst='06:16:3e:1b:72:32')
    ip = scapy.IP(src=src_ip, dst=dst_ip, ttl=ip_ttl)
    udp = proto(sport=srcport, dport=dstport)
    payload = 'helloworld'
    pkt = eth / ip / udp / payload
    return pkt

# Quick turn a packet into a string even if it is None
def pkt_str(pkt):
    if pkt is None:
        return "None"
    elif issubclass(type(pkt), scapy.Packet):
        return pkt.summary() + " " + str(pkt).encode("HEX")
    else:
        return str(pkt).encode("HEX")

# The classic
def aton(ip):
    return socket.inet_aton(ip)


# These are just for the crash test
crash_test_packets = [
    bytes(gen_packet(scapy.UDP, '172.16.100.1', '10.0.0.1')),
    bytes(gen_packet(scapy.UDP, '172.12.55.99', '12.34.56.78')),
    bytes(gen_packet(scapy.UDP, '172.12.55.99', '10.0.0.1')),
    bytes(gen_packet(scapy.UDP, '172.16.100.1', '12.34.56.78')),
    bytes(gen_packet(scapy.TCP, '172.12.55.99', '12.34.56.78')),
    bytes(gen_packet(scapy.UDP, '192.168.1.123', '12.34.56.78'))
]

## TEST FUNCTIONS ##

# All this does is subject a module to load and make sure it
# doesn't crash
def crash_test(module, num_input_ports, num_output_ports):
    for i in range(num_input_ports):
        Source() -> Rewrite(templates=crash_test_packets) -> i:module
    for i in range(num_output_ports):
        module:i -> Sink()

    bess.resume_all()
    time.sleep(5)
    bess.pause_all()

def load_test(filename):
    """
    Load a test file.  It should modify the (global to it) variables
    CRASH_TEST_INPUTS, OUTPUT_TEST_INPUTS, and CUSTOM_TEST_FUNCTIONS
    using .append() to add its tests.  The format of each of these is
    a bit different; see the wiki at
    https://github.com/NetSys/bess/wiki/Python-Scripts
    """
    namespace = {
        '__builtins__': __builtins__,
        'bess': bess,
        'ConfError': ConfError,
        '__bess_env__': __bess_env__,
        '__bess_module__': __bess_module__,
        '__bess_creators__': __bess_creators__,
        'scapy': scapy,
        'socket': socket,
        'time': time,
        'SOCKET_PATH': SOCKET_PATH,
        'SCRIPT_STARTTIME': SCRIPT_STARTTIME,
        'gen_socket_and_port': gen_socket_and_port,
        'gen_packet': gen_packet,
        'pkt_str': pkt_str,
        'aton': aton,
        'monitor_task': monitor_task,
        'CRASH_TEST_INPUTS': [],
        'OUTPUT_TEST_INPUTS': [],
        'CUSTOM_TEST_FUNCTIONS': [],
    }
    # pre-import all the actual creator modules directly
    namespace.update(__bess_creators__)

    xformed = sugar.xform_file(filename)
    code = compile(xformed, filename, 'exec')
    exec(code, namespace)

    # if test deleted any of our items, use an empty list
    return [namespace.get('CRASH_TEST_INPUTS', []),
            namespace.get('OUTPUT_TEST_INPUTS', []),
            namespace.get('CUSTOM_TEST_FUNCTIONS', [])]


def monitor_task(module, wid):
    module.attach_task(wid=wid)


## RUN TEST LOOP ##
def run_tests():
    DID_TESTS_FAIL = False

    path = os.path.dirname(os.path.realpath(sys.argv[0]))

    # Note: os.path.join will discard the leading parts if test
    # begins with '/', so callers should provide an absolute path
    # if and only if they want to override the internal BESS
    # path prefixing.
    for filename in glob.glob(os.path.join(path,
                                           "conf/testing/module_tests",
                                           test_name + ".py")):
        bess.reset_all()

        print("-- Running Module Tests for %s --" % filename.split("/")[-1])

       # Wrap in a function to make sure scope doesn't leak.
        CRASH_TEST_INPUTS, OUTPUT_TEST_INPUTS, CUSTOM_TEST_FUNCTIONS = load_test(
            filename)

        crash_testid = 1
        for module, input_port_cnt, output_port_cnt in CRASH_TEST_INPUTS:
            try:
                crash_test(module, input_port_cnt, output_port_cnt)
                print("   %s crash test %d: PASS" % (str(module), crash_testid))
            except BaseException:
                print("   %s crash test %d: FAIL" % (str(module), crash_testid))
                DID_TESTS_FAIL = True
                print("\n")
                traceback.print_exc()
                print("\n")
            crash_testid += 1

        output_testid = 1
        for module, input_port_cnt, output_port_cnt, test_cases in OUTPUT_TEST_INPUTS:
            input_ports = []
            output_ports = []
            sockets = []
            try:
                for port_num in range(max(input_port_cnt, output_port_cnt)):
                    sockname = module.name + "_" + str(output_testid) + "_moduletesting_" + \
                        SCRIPT_STARTTIME + str(port_num)
                    socket_port, mysocket = gen_socket_and_port(sockname)
                    input_ports.append(PortInc(port=sockname))
                    output_ports.append(PortOut(port=sockname))
                    sockets.append(mysocket)
                    if port_num < input_port_cnt:
                        input_ports[port_num] -> port_num:module
                    if port_num < output_port_cnt:
                        module:port_num -> output_ports[port_num]

                bess.resume_all()

                for test_case in test_cases:
                    input_port = test_case["input_port"]
                    output_port = test_case["output_port"]
                    input_pkt = test_case["input_packet"]
                    output_pkt = test_case["output_packet"]
                    if input_pkt is not None:
                        sockets[input_port].send(bytes(input_pkt))

                    try:
                        received_data = sockets[output_port].recv(2048)
                        try:
                            received_pkt = scapy.Ether(received_data)
                        except:
                            received_pkt = received_data
                    except socket.timeout:
                        received_pkt = None

                    if str(received_pkt) != str(output_pkt):
                        sys.stderr.write("Output test failed!\n")
                        sys.stderr.write("Input packet: %s\n" % pkt_str(input_pkt))
                        sys.stderr.write("Expected: %s\n" % pkt_str(output_pkt))
                        sys.stderr.write("Received: %s\n" % pkt_str(received_pkt))
                        DID_TESTS_FAIL = True
                        print("   %s output test %d: FAIL" %
                              (str(module), output_testid))
                    else:
                        print("   %s output test %d: PASS" %
                              (str(module), output_testid))
                    output_testid += 1
            except BaseException:
                print("   %s output test %d: FAIL" %
                      (str(module), output_testid))
                DID_TESTS_FAIL = True
                print("\n")
                traceback.print_exc()
                print("\n")

            # tests passed!
            for sock in sockets:
                sock.close()
            bess.pause_all()

        for test in CUSTOM_TEST_FUNCTIONS:
            bess.pause_all()
            bess.reset_all()
            try:
                test()
                print("   %s  custom test: PASS" % str(test))
            except BaseException:
                print("   %s  custom test: FAIL" % str(test))
                DID_TESTS_FAIL = True
                print("\n")
                traceback.print_exc()
                print("\n")
        # All done!

    bess.pause_all()
    bess.reset_all()
    return not DID_TESTS_FAIL


# Call our big test function.
if not run_tests():
    print("Some tests failed. :(")
    sys.exit(1)
